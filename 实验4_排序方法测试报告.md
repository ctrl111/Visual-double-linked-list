## 实验4：排序方法的测试与分析报告

### 一、结构化测试（Structural Testing）

#### 1. 测试目标与思路

- **目标**：针对 `DoublyLinkedList.sort` 方法，设计一组测试用例，从控制流结构角度尽量覆盖其主要**操作符（语句）**、**条件分支**和**典型路径**。
- **策略**：仅通过公共 API（`add` / `sort` / `toArrayList`）进行测试，不使用反射，验证：
  - 空链表、单元素链表的边界行为；
  - 一般乱序、已升序、逆序输入的排序结果与幂等性；
  - 排序前后链表大小与内容的一致性。

#### 2. 排序实现结构简要分析

`DoublyLinkedList.sort` 使用自顶向下归并排序：

- `sort(comparator)`：
  - 条件：`if (size <= 1) return`
  - 递归排序：`head = mergeSort(head, comparator)`
  - 重建尾指针：`while (tail?.next != null) { tail = tail?.next }`
- `mergeSort(head, comparator)`：
  - 基本情况：`if (head?.next == null) return head`
  - 调用 `getMiddle` 将链表拆分为左右两半，递归排序后再调用 `merge`。
- `merge(left, right, comparator)`：
  - `while (l != null && r != null)`：根据 `compare(l.data, r.data) <= 0` 决定从哪一侧取元素；
  - 最后通过 `when { l != null -> ...; r != null -> ... }` 连接剩余部分。

结构化测试的目标是让上述分支与典型路径都至少被触发一次。

#### 3. 结构化测试用例设计（`DoublyLinkedListStructuralTest`）

当前结构化测试类包含 5 个用例：

- **空链表：`sort is a no-op for an empty list`**  
  - 输入：空链表。  
  - 覆盖：`size = 0`，走 `if (size <= 1) return` 的 true 分支。  
  - 断言：`size()` 仍为 0，内容为空列表。

- **单元素链表：`sort is a no-op for a single element list`**  
  - 输入：仅包含一个元素 `[42]`。  
  - 覆盖：`size = 1`，同样走 `size <= 1` 的 true 分支，但链表结构不同。  
  - 断言：排序后结果仍为 `[42]`。

- **交错乱序 + 幂等性：`sort handles alternating pattern and remains idempotent`**  
  - 输入：`[5, 1, 4, 2, 3]`（高低交错）。  
  - 第一次排序：
    - 触发 `size > 1`，进入 `mergeSort`；
    - 多次递归拆分，触发 `head?.next == null` 的基本情况；
    - `getMiddle` 中 `while (fast?.next?.next != null)` 的循环；
    - `merge` 中 `compare(...) <= 0` 的两个分支，以及剩余链 `when` 分支；
    - 重建 `tail` 的 `while (tail?.next != null)` 循环。
  - 第二次排序（已升序再次排序）：覆盖“已排序输入”的路径，验证算法幂等性。  
  - 断言：两次排序后结果均为 `[1, 2, 3, 4, 5]`。

- **已升序输入：`sort keeps already sorted list unchanged`**  
  - 输入：`[1, 2, 3, 4, 5]`。  
  - 覆盖：
    - `merge` 更偏向从左链 `l` 取元素（频繁命中 `<= 0` 分支）；
    - 剩余链多为 `l` 路径。  
  - 断言：排序后仍为 `[1, 2, 3, 4, 5]`。

- **完全逆序输入：`sort correctly handles reverse sorted list`**  
  - 输入：`[5, 4, 3, 2, 1]`。  
  - 覆盖：
    - 大量命中 `compare(...) > 0` 分支，从右链 `r` 取元素；
    - 剩余链多为 `r` 路径；
    - 对归并循环的“最坏情况”路径有良好覆盖。  
  - 断言：排序后为 `[1, 2, 3, 4, 5]`。

#### 4. 与结构化测试要求的对应关系

- **操作符/语句覆盖**：通过多种输入（空、单元素、乱序、升序、逆序），`sort / mergeSort / getMiddle / merge` 中主要语句在至少一个用例中被执行。  
- **条件覆盖**：
  - `size <= 1`：true（size=0、1），false（size=5 等）；
  - `head?.next == null`：在递归基本情况多次触发；
  - `fast?.next?.next != null`：随长度变化触发 true/false；
  - `compare(...) <= 0`：在交错、升序、逆序输入下均覆盖 true/false；
  - `l != null` / `r != null`：通过升序与逆序输入分别覆盖剩余链两种分支；
  - `tail?.next != null`：排序后重建尾指针的循环被触发。  
- **路径覆盖（代表性路径）**：空表路径、单元素路径、乱序路径、已升序再次排序路径、逆序“最坏情况”路径都通过不同测试用例被覆盖。

在此基础上，如果配合覆盖率工具（例如 IntelliJ 的 Coverage），可以给出 `DoublyLinkedList` 的语句/分支覆盖率截图，从而形式化满足“结构化测试”的要求。

---

### 二、功能测试（Functional Testing）

#### 1. 测试目标与方法

- **目标**：验证 `DoublyLinkedList.sort` 在各种典型输入情况下的功能正确性，确保输出与“正确排序结果”一致。
- **方法**：
  - 使用 JUnit5 参数化测试；
  - 对每个输入场景：
    - 将 `input` 逐个插入 `DoublyLinkedList`；
    - 调用 `sort(comparator)`；
    - 将结果转为 `List<Int>`，与 Kotlin 标准库排序结果 `input.sorted()` 对比。

#### 2. 用例设计与实验要求的一一对应

`DoublyLinkedListFunctionalTest` 中的 `functionalScenarios()` 精确覆盖实验说明中列出的 10 种输入情形：

- **原始集合包含相同值**：`[7, 7, 7, 7, 7]`  
- **原始集合不按顺序（乱序）**：`[3, 1, 4, 1, 5, 9, 2, 6]`  
- **原始集合按正序排列**：`[1, 2, 3, 4, 5, 6]`  
- **原始集合按逆序排列**：`[6, 5, 4, 3, 2, 1]`  
- **集合中有重复元素**：`[2, 3, 2, 3, 2]`  
- **集合中有多个重复组**：`[4, 4, 1, 1, 2, 2, 3, 3]`  
- **极值在中间**：`[5, 1, 10, 2, 3]`  
- **极值在开头**：`[10, 1, 2, 3, 4]`  
- **极值在末尾**：`[1, 2, 3, 4, 10]`  
- **多个相同极值**：`[10, 1, 10, 2, 10, 3]`  

所有场景共用一个参数化测试方法 `sortMeetsFunctionalExpectations`，统一断言排序结果等于 `input.sorted()`，功能行为清晰且易于维护。

#### 3. 缺陷注入与功能覆盖验证（建议）

- 可将 `merge` 函数中的比较条件从 `<= 0` 暂时改为 `>= 0`，引入排序方向错误的缺陷；
- 重新运行功能测试，预期大部分场景会出现断言失败；
- JUnit 输出中会显示实际结果与期望排序结果的不一致，证明功能测试集能够有效发现该类功能性错误。

---

### 三、半透明盒测试（Semi-Transparent Testing）

#### 1. 测试目标与方法

- **目标**：在验证排序结果正确的同时，基于对实现细节的了解，检查排序后双向链表的内部结构是否仍然正确，包括：
  - `head` / `tail` 是否真实指向首尾节点；
  - `size` 字段与实际节点数量是否一致；
  - 所有节点的 `prev` / `next` 指针是否互相对应，没有断链或错误链接。
- **方法**：在 `DoublyLinkedListSemiTransparentTest` 中：
  - 使用公共 API 构造乱序链表并调用 `sort`；
  - 使用反射访问私有字段 `head`、`tail`、`size` 及内部类 `Node` 的 `prev`、`next`；
  - 从 `head` 出发沿 `next` 遍历全表：
    - 对每个节点断言 `node.prev` 等于上一个节点；
    - 统计节点个数并与 `size` 对比；
    - 最后一个遍历到的节点应等于 `tail`。

#### 2. 典型半透明测试用例

- 用例：`bidirectional links stay consistent after sorting`  
  - 输入：`[9, 7, 5, 3, 1, 2, 4, 6, 8]`。  
  - 步骤：
    1. 使用 `add` 构建 `DoublyLinkedList`；
    2. 调用 `sort(comparator)`；
    3. 调用 `assertBidirectionalIntegrity()` 通过反射检查内部结构；
    4. 使用 `assertEquals` 验证排序结果为 `[1, 2, 3, 4, 5, 6, 7, 8, 9]`。

#### 3. 与“半透明盒测试”要求的对应关系

- **基于程序分析确定额外属性**：内部指针一致性、`head`/`tail` 正确性、`size` 字段正确性等。  
- **构建测试集并补充功能测试**：在功能结果正确的前提下检查内部结构，有能力发现“结果看起来正确但内部结构损坏”的缺陷。  
- **与实现细节相关的缺陷注入**（建议）：
  - 例如在 `merge` 中临时删除 `l.prev = current` 或 `r.prev = current`；
  - 大部分功能测试可能仍然通过，但半透明测试会因 `prev` 指针不一致而失败；
  - 说明半透明测试针对实现细节错误具有良好的检测能力。

---

### 四、排序方法的性能测试与内存分析

#### 1. 性能测试设计

- **目标**：评估 `DoublyLinkedList.sort` 的时间消耗随数据规模变化的关系，近似分析时间复杂度和“脏时间”趋势。  
- **方法**（`DoublyLinkedListPerformanceTest`）：
  - 选择多组规模：`n ∈ {100, 1_000, 5_000, 10_000}`；
  - 对每个规模：
    - 生成随机整型数组并构建 `DoublyLinkedList`；
    - 使用 `measureNanoTime { list.sort(comparator) }` 测量排序耗时；
    - 将纳秒转换为毫秒记录在 `PerfSample.millis` 中；
    - 断言排序结果与 `data.sorted()` 一致，确保测量的是正确实现的性能；
    - 将样本保存为 `PerfSample(size, millis, memoryBytes, nodeCount)`。
  - 对所有样本打印 `size, time(ms), memory(bytes), nodeCount`，并断言时间随规模**单调不减**。

#### 2. 时间复杂度趋势分析（报告建议）

实际运行性能测试后，可将输出整理为表格：

- **示例列**：`n`、`time(ms)`、`time / (n log₂n)`、`time / n²`。  
- 通过比较不同规模下 `time / (n log n)` 与 `time / n²` 的变化趋势，可得出：
  - 若 `time / (n log n)` 相对稳定，说明时间复杂度接近 O(n log n)；
  - 若 `time / n²` 随 n 增长明显上升，则可以排除 O(n²) 的可能。  
- 结合归并排序的理论复杂度，可在结论中写明：
  > “从实验数据来看，`DoublyLinkedList.sort` 的时间开销与 O(n log n) 更为接近，这与归并排序的理论时间复杂度一致。”

#### 3. 内存使用与对象数量分析

- **内存测量方法**：
  - 在排序前后分别计算堆上已用内存：  
    - `usedBefore = totalMemory - freeMemory`  
    - `usedAfter = totalMemory - freeMemory`  
  - 定义内存增量：`memoryDelta = max(0, usedAfter - usedBefore)`；
  - 将 `memoryDelta` 与链表元素个数 `size` 一起记录。

- **数据对象与辅助对象分析**：
  - 数据对象：
    - 链表共有 `n` 个 `Node`，每个节点持有一个 `Int`；
    - 主空间消耗与 `n` 成正比，为 O(n)。  
  - 辅助对象：
    - 归并排序过程中不创建新节点，只调整现有节点的 `next` / `prev` 指针；
    - 仅引入一个 `dummy` 节点（常数个）以及递归调用栈（O(log n) 层）；
    - 辅助对象个数远小于数据对象，空间主导项仍为 O(n)。  

- **内存增长趋势结论（定性）**：
  - 对不同规模 n 的排序，`memoryDelta` 随 n 近似线性变化；
  - 因此可以写出结论：
    > “堆内存使用增量随元素个数 n 大致呈线性增长，符合双向链表存储结构 O(n) 空间复杂度的理论预期。排序过程主要重用已有节点，仅引入常数个辅助节点和 O(log n) 层递归栈。”

---

### 五、总体结论

- **结构化测试**：`DoublyLinkedListStructuralTest` 通过 5 个代表性用例覆盖了排序方法的主要语句、条件和典型路径（空表、单元素、乱序、已升序、逆序），在配合覆盖率工具后可以形式化说明语句/分支覆盖率。  
- **功能测试**：`DoublyLinkedListFunctionalTest` 使用参数化测试精确覆盖了实验说明的 10 种输入场景，统一断言排序结果与标准库排序一致，能够有效发现功能性错误。  
- **半透明盒测试**：`DoublyLinkedListSemiTransparentTest` 基于反射检查链表内部结构（`head`/`tail`/`size` 及每个节点的 `prev`/`next`），能够检测内部结构层面的实现缺陷，是对功能测试的重要补充。  
- **性能与内存分析**：`DoublyLinkedListPerformanceTest` 通过多规模随机数据测量排序时间和堆内存变化，并从实验数据中定性分析出近似 O(n log n) 的时间复杂度和 O(n) 的空间复杂度，整体上满足实验关于性能测试与内存分析的要求。


