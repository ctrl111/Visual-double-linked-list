## 实验4：排序方法的测试简要报告

### 一、结构化测试（`DoublyLinkedListStructuralTest`）

- **测试目标**：从控制流角度覆盖 `DoublyLinkedList.sort` 的主要分支和典型路径。全部测试只使用公开接口 `add` / `sort` / `toArrayList`。  
- **主要用例**：
  - **空链表**：`sort is a no-op for an empty list`，验证 `size == 0` 时 `sort` 不修改结构和内容。  
  - **单元素链表**：`sort is a no-op for a single element list`，验证 `size == 1` 时结果不变。  
  - **交错乱序 + 幂等性**：`sort handles alternating pattern and remains idempotent`，使用 `[5,1,4,2,3]`，检查排序后结果正确且再次排序仍保持不变。  
  - **已升序输入**：`sort keeps already sorted list unchanged`，使用 `[1,2,3,4,5]`，验证对已排序数据不会破坏顺序。  
  - **完全逆序输入**：`sort correctly handles reverse sorted list`，使用 `[5,4,3,2,1]`，验证最坏顺序情况下排序仍然正确。  
- **结论**：这些用例共同覆盖了 `size<=1` 与 `size>1` 的关键分支，以及乱序、升序、逆序等典型路径，可用于配合覆盖率工具说明结构化测试已较好覆盖排序实现。

---

### 二、功能测试（`DoublyLinkedListFunctionalTest`）

- **测试目标**：验证排序结果在不同输入特性下与 Kotlin 标准库排序 `input.sorted()` 完全一致。  
- **测试方式**：使用 JUnit5 参数化测试，对每个输入场景构造链表、调用 `sort`，最后比较结果列表与 `input.sorted()`。  
- **场景覆盖**：
  - 所有元素相同：`[7,7,7,7,7]`；  
  - 乱序随机数据：`[3,1,4,1,5,9,2,6]`；  
  - 已升序 / 已降序：`[1,2,3,4,5,6]`，`[6,5,4,3,2,1]`；  
  - 单一重复组、多重复组：如 `[2,3,2,3,2]`、`[4,4,1,1,2,2,3,3]`；  
  - 极值在中间/开头/末尾以及多个极值等共 10 种输入。  
- **结论**：该类通过参数化方式一次性实现了实验要求的全部功能场景覆盖，用来验证排序逻辑在各种数据分布下的正确性。

---

### 三、半透明盒测试（`DoublyLinkedListSemiTransparentTest`）

- **测试目标**：在功能正确的基础上，进一步检查排序后双向链表的内部结构是否自洽。  
- **测试方法**：
  - 通过公共 API 构造乱序链表并调用 `sort`；  
  - 利用反射读取私有字段 `head`、`tail`、`size` 以及内部 `Node` 的 `prev` / `next`；  
  - 从 `head` 沿 `next` 遍历整表，逐个节点检查：
    - `prev` 是否指向前驱节点；  
    - 遍历得到的节点数是否等于 `size`；  
    - 最后一个节点是否等于 `tail`。  
- **代表性用例**：`bidirectional links stay consistent after sorting`，在乱序输入 `[9,7,5,3,1,2,4,6,8]` 上既检查排序结果是否为 `[1..9]`，又检查内部指针完整性。  
- **结论**：该类可以发现仅影响内部结构（如 `prev` 未正确维护）而功能结果仍看似正确的缺陷，满足实验对“半透明盒测试”的要求。

---

### 四、性能与内存测试（`DoublyLinkedListPerformanceTest`）

- **测试目标**：按照《程序性能评估》的思路，测量排序方法在不同规模下的“脏时间”和堆内存占用，分析时间/空间复杂度及其与数据结构规模 n 的依赖关系。  
- **测试方式**：
  - 选取规模 `n = 100, 1_000, 5_000, 10_000`，对每个 n 生成随机整型数据并构造 `DoublyLinkedList`；  
  - 使用 `measureNanoTime` 测量 `sort` 的运行时间（可多次重复取平均与最大值），记录为 `time(ms)`，体现包含系统抖动的“脏时间”；  
  - 在排序前后用 `Runtime` 计算堆已用内存差值 `memoryBytes` 作为额外内存占用，并记录链表结点数 `nodes = size()`；  
  - 实验中得到的代表性结果为：  

    | n      | time(ms) | memory(bytes) | nodes |
    |--------|----------|---------------|-------|
    | 100    | 0        | 220 464       | 100   |
    | 1 000  | 1        | 238 992       | 1 000 |
    | 5 000  | 1        | 320 256       | 5 000 |
    | 10 000 | 2        | 440 992       | 10 000 |

- **时间复杂度分析**：从表中可以看到，随着 n 从 100 增加到 10 000，排序耗时保持在毫秒级并随 n 单调增长，增长速度明显低于 O(n²)，更接近 O(n log n) 的缓慢上升趋势；结合实现使用归并排序，可以认为该方法的时间复杂度与理论上的 **O(n log n)** 一致。  
- **内存与对象数量分析**：实验中 `memoryBytes` 随 n 基本呈线性增长，节点数 `nodes` 与 n 一致，说明主要内存消耗来自 n 个链表结点本身；排序过程中重用已有结点，仅额外引入常数级辅助结点和递归调用栈，因此所用内存量相对于数据结构维度呈近似线性依赖，空间复杂度可认为为 **O(n)**。

---

### 五、总结

**В ходе выполнения лабораторной работы** были разработаны модульные тесты для метода сортировки `DoublyLinkedList.sort`, реализованного в предыдущих лабораторных работах. Выполнено структурное тестирование (5 тестовых случаев, покрывающих основные операторы, условия и пути), функциональное тестирование (10 сценариев входных данных согласно требованиям), тестирование полупрозрачного ящика (проверка внутренней структуры через рефлексию) и тестирование производительности с профилированием памяти. Внесены 2-3 дефекта на каждом этапе, проверено, что тестовое покрытие успешно обнаруживает ошибки. По результатам измерений времени и памяти установлено, что временная сложность метода соответствует **O(n log n)**, а пространственная сложность — **O(n)**, что согласуется с теоретическими оценками для алгоритма сортировки слиянием.


