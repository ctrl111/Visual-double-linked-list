架构接口 (Interfaces)
Interface UserType
定义用户数据类型的规范，提供获取类型名称、创建实例、解析值和获取比较器的方法。通过Kotlin接口的多态性实现不同类型数据的统一处理。包含方法：typeName()、create()、clone()、readValue()、parseValue()和getTypeComparator()。

Interface Comparator
定义对象比较的契约，通过方法compare(o1: Any?, o2: Any?): Int实现。用于排序和查找操作。作为接口实现，用作函数式接口，提供灵活的数据类型比较机制。

Fun Interface DoWith
定义对对象执行操作的规范，通过方法doWith(obj: Any?): Unit实现。作为函数式接口（fun interface）用于命令式风格的集合元素遍历。在forEach()方法中使用，对列表中的每个元素执行操作。

Fun Interface TestIt
定义元素测试条件，通过方法testIt(obj: Any?): Boolean实现。用于在数据结构中查找满足特定条件的对象。实现为函数式接口，应用于firstThat()方法中查找第一个匹配的元素。

主要组件实现
Class DoublyLinkedList
实现双向链表，提供添加、插入、删除和获取元素的操作。类提供两种风格的元素遍历方法：
- 命令式风格：forEach(action: DoWith)、firstThat(test: TestIt)
- 函数式风格：通过函数式接口支持Lambda表达式
包含高效的递归归并排序算法实现，时间复杂度O(n log n)，通过方法sort()、mergeSort()、merge()和getMiddle()实现。
内部类：private class Node(var data: Any?, var prev: Node?, var next: Node?) - 支持双向链接结构的链表节点。

Class UserFactory
作为工厂类，用于创建不同类型的数据。包含方法getTypeNameList(): ArrayList<String>和getBuilderByName(name: String): UserType?用于类型管理。使用Kotlin的when表达式选择相应的数据类型。通过向工厂添加新类型，确保系统的易扩展性。

支持的数据类型实现
Class IntegerType
提供整数值的处理。使用try-catch进行安全的字符串解析，并提供内部类IntegerComparator通过内置方法Int.compareTo()进行数值比较。实现UserType接口的所有方法，包括处理解析错误值时的异常处理。

Class StringType
实现字符串数据的处理，支持字典序排序。比较器使用标准方法String.compareTo()进行字母顺序排序。提供简单的parseValue()实现，直接返回原始字符串，无需额外处理。

Class Point2DType
提供二维点数据的处理功能。解析格式为"(x,y)"或"x,y"的字符串，通过try-catch处理错误。关联的data class Point2D(x: Double, y: Double)包含方法distanceFromOrigin()用于计算到原点的距离，在Point2DComparator中用于按距离原点远近对点进行排序。

用户界面管理
Class ListController
JavaFX应用程序的中央控制器，实现MVC模式。协调UI和数据结构之间的交互。处理操作：添加、删除、插入、查找、排序元素，并通过图形表示提供列表状态的可视化。
文件操作：支持JSON格式（手动解析）和二进制格式（使用DataInputStream/DataOutputStream）的数据导入/导出。使用Kotlin现代特性：try-catch处理错误、use()自动资源管理、lateinit延迟初始化UI组件、when表达式进行条件逻辑。
可视化：updateVisualization()方法使用JavaFX的VBox和Label创建列表的图形表示，显示带索引和值的节点，用箭头连接以演示双向链接结构。

应用程序入口点
Class Main
扩展JavaFX的Application类。初始化图形界面，通过FXMLLoader加载FXML文件，创建并配置主窗口（Stage），启动JavaFX的主要事件处理循环。入口点main()使用Application.launch()启动JavaFX应用程序。

归并排序实现
时间复杂度：O(n log n)
算法通过递归将列表分成两半，对每部分进行排序，然后合并：
1.	sort(comparator) - 入口点，调用mergeSort并更新tail指针
2.	mergeSort(head, comparator) - 递归地分割列表并排序各部分
3.	getMiddle(head) - 通过双指针技术（快慢指针）找到中点，O(n)
4.	merge(left, right, comparator) - 合并两个已排序的列表，恢复双向链接结构，O(n)
分析：
- 分割：O(log n)层递归
- 每层合并：O(n)
- 总计：O(n log n)
- 空间复杂度：O(log n)用于调用栈
实现特点：使用虚拟节点（dummy node）简化合并逻辑，正确恢复prev和next指针以在排序后维护双向链接结构。
